<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <!-- Security & privacy policies -->
    <!-- Allow self-hosted scripts and secure external scripts; keep styles and images restricted. -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; img-src 'self' data: https:; style-src 'self' 'unsafe-inline' https:; script-src 'self' 'unsafe-inline' https:; frame-ancestors 'none';">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="permissions-policy" content="geolocation=()">
    <title>Villa BraÅ¡ina â€” Mlini, Dubrovnik</title>
    <meta name="description" content="Villa BraÅ¡ina apartments in Mlini, near Dubrovnik. Sea views, comfortable stays listed on Booking.com and Airbnb.">
    <style>
        /* Auth button styles */
        .auth-container{display:flex;gap:8px;align-items:center}
        .auth-btn{padding:8px 12px;border-radius:8px;border:1px solid #000;background:#fff;cursor:pointer;font-weight:600}
        .auth-btn.primary{background:var(--accent);color:#fff;border-color:#065a78}
        .auth-btn.admin{background:#ffd;color:#000}
        .auth-btn.hidden{display:none}
        :root{--accent:#0a7db1;--muted:#666;--bg:#ffd0da;--card:#fff}
        *{box-sizing:border-box}
        body{font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;margin:0;background-color:var(--bg);color:#222;position:relative}
        /* fine dotted texture overlay on the pink background */
        body::before{content:'';position:fixed;inset:0;pointer-events:none;background-image:radial-gradient(rgba(0,0,0,0.1) 0.8px, transparent 0.8px);background-size:8px 8px;opacity:0.8;z-index:-1}

        /* light shadows for header and cards */
        header{box-shadow:0 6px 18px rgba(10,20,30,0.12)}
        .card{box-shadow:0 6px 18px rgba(10,20,30,0.06)}
        .wrap{max-width:1100px;margin:0 auto;padding:18px}
        header{position:relative;background:linear-gradient(135deg, #0a7db1 0%, #076b93 100%);color:#fff;padding:48px 12rem 48px 48px;border-radius:8px;border:6px solid #000}
        header h1{margin:0;font-size:2rem}
        header p.lead{margin:8px 0 18px;opacity:0.95}
        .actions{display:flex;gap:12px}
        .btn{display:inline-block;padding:9px 13px;border-radius:8px;text-decoration:none;color:#fff;font-weight:600;border:1px solid #000}
        .btn-book{background:var(--accent)}
        .btn-airbnb{background:#FF5A5F}
        main{margin-top:18px}
        .grid{display:grid;grid-template-columns:2fr 1fr;gap:14px}
        .card{background:var(--card);padding:14px;border-radius:8px;box-shadow:0 1px 6px rgba(0,0,0,0.06);border:2px solid #000}
        .features{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px;list-style:none;padding:0;margin:0}
        .features li{background:#f3f7fb;padding:8px;border-radius:6px;text-align:center;border:1.5px solid #000}
        .gallery{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:12px}
        .notes{background:rgba(255,255,255,0.9);border-radius:8px;padding:10px 12px;color:#444;margin-top:10px;border:1px solid #000}
        .gallery img{width:100%;height:140px;object-fit:cover;border-radius:6px;border:1px solid #000}
        .map-wrap{border-radius:6px;overflow:hidden;border:2px solid #000;box-shadow:0 6px 18px rgba(10,20,30,0.08)}

        /* header badge: vertically centered and fully inside the header. */
        .header-badge{position:absolute;top:100px;right:10px;transform:translateY(-50%);height:250px;max-width:250px;width:auto;background-color:transparent !important;padding:0}

        @media(max-width:800px){
            .header-badge{height:360px;max-width:360px}
        }
    .booking-box{display:flex;flex-direction:column;gap:10px;align-items:stretch}
    .unavailable{color:#c00;font-weight:700}
    .booked-badge{display:inline-block;background:#333;color:#fff;padding:2px 6px;border-radius:4px;font-size:0.85rem;margin-left:6px}
    .availability-list{list-style:none;padding:0;margin:8px 0}
    .availability-list li{background:#f3f3f3;padding:6px;border-radius:4px;margin-bottom:6px;border:1px solid #ddd}
        .big-btn{display:block;text-align:center;padding:10px 12px;border-radius:8px;color:#fff;font-weight:700;text-decoration:none;border:1px solid #000}
        .big-book{background:var(--accent)}
        .big-airbnb{background:#FF5A5F}
        footer{margin-top:18px;color:var(--muted);text-align:center}
        @media(max-width:800px){.grid{grid-template-columns:1fr}.gallery{grid-template-columns:repeat(1,1fr);}.actions{flex-direction:column;align-items:flex-start}}
        /* style for links disabled by the sanitizer */
        .disabled-link{opacity:0.6;pointer-events:none;cursor:not-allowed;text-decoration:line-through;color:#888}
        /* style booked days in flatpickr pickers */
        .flatpickr-day.flatpickr-disabled{background:#fde2e2;color:#7a1212;border-radius:6px}
        /* Admin reset panel (hidden by default, shown via Ctrl+Shift+R) */
        #adminResetModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:9999;flex-direction:column;align-items:center;justify-content:center}
        #adminResetModal.show{display:flex}
        #adminResetModal .modal-content{background:#fff;padding:24px;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,0.3);max-width:400px;text-align:center;border:2px solid #000}
        #adminResetModal h3{margin-top:0;color:#c00}
        #adminResetModal p{color:#666;line-height:1.5;margin:12px 0}
        #adminResetModal .modal-buttons{display:flex;gap:8px;margin-top:16px;justify-content:center}
        #adminResetModal .modal-btn{padding:10px 16px;border-radius:8px;border:1px solid #000;font-weight:600;cursor:pointer;transition:all 0.2s}
        #adminResetModal .reset-btn{background:#c00;color:#fff}
        #adminResetModal .reset-btn:hover{background:#a00;transform:scale(1.05)}
        #adminResetModal .cancel-btn{background:#ccc;color:#000}
        #adminResetModal .cancel-btn:hover{background:#aaa}
    </style>
    <!-- flatpickr for consistent date pickers across browsers -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
</head>
<body>
    <div class="wrap">
        <header>
            <h1>Villa BraÅ¡ina</h1>
            <p class="lead">Cozy apartments in Mlini, Dubrovnik â€” private balconies, and short walk to the beach.</p>
            <!-- badge image (place your image file as 'villa-badge.png' in the same folder) -->
            <img class="header-badge" src="ChatGPT%20Image%2026.%20lis%202025.%2009_49_10.png" alt="Villa BraÅ¡ina badge">
            <!-- sign-in moved below header into main left column -->

        </header>

        <main>
            <div class="grid">
                <div>
                    <div id="inlineSignInContainer" class="auth-container" style="margin-bottom:12px">
                        <div id="inlineSignIn"></div>
                        <button id="fallbackSignInBtn" class="auth-btn" type="button">Sign in</button>
                        <button id="adminAccessBtn" class="auth-btn admin" type="button" style="display:none">Admin</button>
                        <button id="inlineSignOut" class="auth-btn primary" type="button" style="display:none">Sign out</button>
                    </div>
                    <section class="card">
                        <h2>About Villa BraÅ¡ina</h2>
                        <p>Villa BraÅ¡ina is a family-run property located in the seaside village of Mlini, just a short drive from Dubrovnik Old Town. Guests enjoy bright apartments with modern amenities, private balconies, and quick access to local beaches and restaurants.</p>

                        <h3>Highlights</h3>
                        <ul class="features">
                            <li>BBQ equipment</li>
                            <li>Outdoor pool (seasonal)</li>
                            <li>Billiards</li>
                            <li>Air conditioning</li>
                            <li>Free Wiâ€‘Fi</li>
                            <li>Fully equipped kitchen</li>
                            <li>Short walk to the beach</li>
                            <li>Free parking</li>
                        </ul>

                        <h3 id="galleryTitle" class="mt">Gallery</h3>
                        <div id="gallery" class="gallery">
                            <img loading="lazy" src="163596176.webp">
                            <img loading="lazy" src="163613119.jpg">
                            <img loading="lazy" src="preuzmi.jpg">
                        </div>
                        <div class="notes" aria-label="Important notes" style="margin-top:12px">
                            <h4 style="margin:0 0 8px">Please note</h4>
                            <ul style="margin:0;padding-left:18px;color:#555;font-size:0.95rem;line-height:1.5">
                                <li>The outdoor pool is open from 15 May to 15 September (approx. 9:00am â€” 9:00pm).</li>
                                <li>Due to sefty risks, jumping into the pool is prohibited.</li>
                                <li>Guests booking 5 days or more are entitled to a free shuttle service to Dubrovnik Airport.</li>
                                <li>Please inform Villa BraÅ¡ina in advance of your expected arrival time via the Special Requests box or contact details in your confirmation.</li>
                                <li>The property is under constant video surveillance for guest and property safety.</li>
                            </ul>
                        </div>
                    </section>
                </div>

                <aside>
                    <div class="card booking-box" id="booking">
                        <h3>Book your stay</h3>
                        <p>Fill in your booking details below to book online â€” available dates will be reserved immediately.</p>
                        <form id="contactForm" aria-label="Booking contact form">
                            <label for="c_name">Full name</label>
                            <input id="c_name" name="name" type="text" required style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">

                            <label for="c_email">Your email</label>
                            <input id="c_email" name="email" type="email" required style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">
                            <div id="googleSignIn" style="margin-top:6px;display:none"></div>

                            <label for="c_phone">Phone (optional)</label>
                            <input id="c_phone" name="phone" type="tel" style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">

                            <label for="c_room">Room number</label>
                                <select id="c_room" name="Room" required style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">
                                    <option value="">-- select room # --</option>
                                    <option value="1" data-max-guests="1" data-price="50">1 (max guests 1) â€” â‚¬50/night</option>
                                    <option value="2" data-max-guests="2" data-price="50">2 (max guests 2) â€” â‚¬50/night</option>
                                    <option value="3" data-max-guests="2" data-price="45">3 (max guests 2) â€” â‚¬45/night</option>
                                    <option value="4" data-max-guests="4" data-price="70">4 (max guests 4) â€” â‚¬70/night</option>
                                    <option value="5" data-max-guests="3" data-price="55">5 (max guests 3) â€” â‚¬55/night</option>
                                    <option value="6" data-max-guests="6" data-price="80">6 (max guests 6) â€” â‚¬80/night</option>
                                    <option value="7" data-max-guests="3" data-price="60">7 (max guests 3) â€” â‚¬60/night</option>
                                    <option value="8" data-max-guests="3" data-price="60">8 (max guests 3) â€” â‚¬60/night</option>
                                    <option value="9" data-max-guests="8" data-price="60">9 (max guests 8) â€” â‚¬60/night</option>
                                    <option value="10" data-max-guests="4" data-price="70">10 (max guests 4) â€” â‚¬70/night</option>
                                    <option value="11" data-max-guests="3" data-price="55">11 (max guests 3) â€” â‚¬55/night</option>
                                    <option value="12" data-max-guests="6" data-price="80">12 (max guests 6) â€” â‚¬80/night</option>
                                    <option value="13" data-max-guests="3" data-price="55">13 (max guests 3) â€” â‚¬55/night</option>
                                    <option value="14" data-max-guests="8" data-price="80">14 (max guests 8) â€” â‚¬80/night</option>
                                    <option value="15" data-max-guests="3" data-price="55">15 (max guests 3) â€” â‚¬55/night</option>
                                </select>

                            <div id="dateFields" style="display:none">
                                <div style="display:flex;gap:8px;align-items:center">
                                    <div style="flex:1">
                                        <label for="c_checkin">Check-in</label>
                                        <input id="c_checkin" name="checkin" type="date" style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">
                                    </div>
                                    <div style="flex:1">
                                        <label for="c_checkout">Check-out</label>
                                        <input id="c_checkout" name="checkout" type="date" style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">
                                    </div>
                                </div>
                                <!-- availability will be shown on the existing date pickers (check-in / check-out) -->
                            </div>
                            <div id="guestsField" style="display:none">
                                <label for="c_guests">Number of guests (max 4)</label>
                                <input id="c_guests" name="guests" type="number" min="0" max="4" value="0" style="width:100%;padding:8px;margin-top:6px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc">
                            </div>

                            <!-- price display (updated dynamically) -->
                            <p id="priceDisplay" style="margin-top:8px;font-weight:700;color:#064;display:none">Estimated total: â‚¬0</p>

                            <p id="availabilityStatus" role="status" aria-live="polite" style="margin-top:8px;margin-bottom:8px;color:#064;font-weight:600"></p>

                            <!-- additional requests removed per request -->

                            <div style="display:flex;gap:8px;align-items:center">
                                    <button type="submit" class="big-btn big-book" style="width:100%">Book your stay</button>
                                </div>
                            <p id="contactStatus" role="status" aria-live="polite" style="margin-top:8px;color:#064"></p>
                        </form>
                    </div>



                    <div class="card" style="margin-top:12px">
                        <h3>Location</h3>
                        <p>Mlini, just south of Dubrovnik â€” known for pebble beaches, calm waters, and a relaxed seaside atmosphere. Easy bus connections to Dubrovnik Old Town.</p>
                        <!-- Responsive Google Maps iframe embed for Villa BraÅ¡ina -->
                        <div class="map-wrap" style="position:relative;overflow:hidden;padding-top:56.25%;border-radius:6px;margin-top:8px">
                            <iframe loading="lazy" src="https://www.google.com/maps?q=Villa%20BraÅ¡ina%20Mlini&output=embed" style="border:0;position:absolute;top:0;left:0;width:100%;height:100%;" allowfullscreen="" referrerpolicy="no-referrer-when-downgrade"></iframe>
                        </div>
                        <p style="font-size:0.9rem;color:#666;margin-top:8px">Interactive map powered by Google Maps. Click the marker to open directions or view the full listing.</p>
                    </div>
                </aside>
            </div>
        </main>

        <footer>
            <p>&copy; Villa BraÅ¡ina â€” Mlini, Dubrovnik</p>
        </footer>
    </div>

    <!-- Admin reset modal (hidden by default, triggered by Ctrl+Shift+R) -->
    <div id="adminResetModal">
        <div class="modal-content">
            <h3>ðŸ”§ Admin Reset</h3>
            <p>Clear all bookings and reset calendars. This is for testing only.</p>
            <div class="modal-buttons">
                <button class="modal-btn reset-btn" id="confirmResetBtn">Reset All Bookings</button>
                <button class="modal-btn cancel-btn" id="cancelResetBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Safe URL sanitizer: validates and normalizes href/src values for anchors and iframes. -->
    <script>
    // Google Identity Services: header sign-in, persistent profile, autofill editable fields
    (function(){
        const CLIENT_ID = ''; // TODO: set your OAuth client ID

        function decodeJwtPayload(token){
            try{
                const parts = token.split('.');
                if(parts.length < 2) return null;
                const payload = parts[1].replace(/-/g,'+').replace(/_/g,'/');
                const json = atob(payload);
                return JSON.parse(json);
            }catch(e){ return null; }
        }

        function saveProfile(profile){
            try{ localStorage.setItem('vb_user', JSON.stringify(profile)); }catch(e){}
        }

        function clearProfile(){ try{ localStorage.removeItem('vb_user'); sessionStorage.removeItem('vb_id_token'); }catch(e){} }

        function applyProfile(profile){
            if(!profile) return;
            const emailEl = document.getElementById('c_email');
            const nameEl = document.getElementById('c_name');
            if(emailEl && profile.email) { emailEl.value = profile.email; }
            if(nameEl && profile.name) { nameEl.value = profile.name; }
        }

        function showSignedInUI(profile){
            updateAuthUI(profile);
        }

        function showSignedOutUI(){
            updateAuthUI(null);
        }

        function renderGoogleButton(){
            try{
                const btnTarget = document.getElementById('inlineSignIn');
                if(!btnTarget) return;
                // only render if Google library and CLIENT_ID configured
                if(window.google && google.accounts && google.accounts.id && CLIENT_ID){
                    // clear previous contents to avoid duplicates
                    btnTarget.innerHTML = '';
                    google.accounts.id.renderButton(btnTarget, { theme: 'outline', size: 'large' });
                }
            }catch(e){ console.warn('renderGoogleButton', e); }
        }

        function updateAuthUI(profile){
            const inlineSignIn = document.getElementById('inlineSignIn');
            const fallbackBtn = document.getElementById('fallbackSignInBtn');
            const signOutBtn = document.getElementById('inlineSignOut');
            const adminBtn = document.getElementById('adminAccessBtn');
            const adminEmail = (window.OWNER_EMAIL || 'prodragonno1@gmail.com').toLowerCase();
            if(profile && profile.email){
                if(inlineSignIn) inlineSignIn.style.display = 'none';
                if(fallbackBtn) fallbackBtn.style.display = 'none';
                if(signOutBtn) signOutBtn.style.display = 'inline-block';
                if(adminBtn){ if(profile.email.toLowerCase() === adminEmail) adminBtn.style.display = 'inline-block'; else adminBtn.style.display = 'none'; }
                applyProfile(profile);
            } else {
                if(inlineSignIn) inlineSignIn.style.display = 'block';
                if(fallbackBtn) fallbackBtn.style.display = 'inline-block';
                if(signOutBtn) signOutBtn.style.display = 'none';
                if(adminBtn) adminBtn.style.display = 'none';
                // ensure Google button is present
                renderGoogleButton();
            }
        }

        function onCredential(credentialResponse){
            if(!credentialResponse || !credentialResponse.credential) return;
            const token = credentialResponse.credential;
            sessionStorage.setItem('vb_id_token', token);
            const payload = decodeJwtPayload(token) || {};
            // Require verified gmail address from Google sign-in
            const email = payload.email || '';
            const emailVerified = (payload.email_verified === true || payload.email_verified === 'true');
            if(!emailVerified){ alert('Google account email not verified. Please use a verified Gmail account.'); return; }
            if(!/[@]gmail\.com$/i.test(email) && !/[@]googlemail\.com$/i.test(email)){
                alert('Please sign in with a Gmail address (example@gmail.com).');
                return;
            }
            const profile = { email: email, name: payload.name || '' };
            // If name missing, ask user once
            if(!profile.name){ try{ const n = prompt('Please enter your full name:'); if(n) profile.name = n; }catch(e){} }
            saveProfile(profile);
            applyProfile(profile);
            updateAuthUI(profile);
        }

        function init(){
            // Wire up sign-out
            const signOutBtn = document.getElementById('inlineSignOut');
            if(signOutBtn){ signOutBtn.addEventListener('click', function(){ clearProfile(); showSignedOutUI(); try{ google.accounts.id.disableAutoSelect(); }catch(e){} }); }

            // If stored profile exists, use it
            try{
                const raw = localStorage.getItem('vb_user');
                if(raw){ const profile = JSON.parse(raw); updateAuthUI(profile); }
            }catch(e){}

            // When fields change, persist updates to profile so user can edit their name/email
            try{
                const emailEl = document.getElementById('c_email');
                const nameEl = document.getElementById('c_name');
                [emailEl, nameEl].forEach(el=>{
                    if(!el) return;
                    el.addEventListener('input', function(){
                        try{
                            const raw = localStorage.getItem('vb_user');
                            const profile = raw ? JSON.parse(raw) : { email: '', name: '' };
                            profile.email = (document.getElementById('c_email')||{}).value || profile.email;
                            profile.name = (document.getElementById('c_name')||{}).value || profile.name;
                            saveProfile(profile);
                        }catch(e){}
                    });
                });
            }catch(e){}

            // Initialize Google button if available (render via helper)
            if(window.google && google.accounts && google.accounts.id){
                google.accounts.id.initialize({ client_id: CLIENT_ID, callback: onCredential });
                renderGoogleButton();
                // auto prompt if no profile stored
                try{ const raw = localStorage.getItem('vb_user'); if(!raw) google.accounts.id.prompt(); }catch(e){}
            } else {
                // Wait for library and then render
                document.addEventListener('DOMContentLoaded', function(){ if(window.google && google.accounts && google.accounts.id){ google.accounts.id.initialize({ client_id: CLIENT_ID, callback: onCredential }); renderGoogleButton(); } });
            }
            // Fallback sign-in button behaviour
            try{
                const fallback = document.getElementById('fallbackSignInBtn');
                if(fallback){
                    fallback.addEventListener('click', function(){
                        const email = prompt('Enter your Gmail address (example@gmail.com):');
                        if(!email) return alert('Email is required to sign in.');
                        if(!/[@]gmail\.com$/i.test(email) && !/[@]googlemail\.com$/i.test(email)){
                            if(!confirm('The email you entered is not a Gmail address. It cannot be verified automatically. Continue?')) return;
                        }
                        const name = prompt('Enter your full name:') || '';
                        const profile = { email: String(email).trim(), name: String(name).trim() };
                        try{ saveProfile(profile); }catch(e){}
                        updateAuthUI(profile);
                    });
                }
            }catch(e){ console.warn('fallback sign-in wiring failed', e); }
        }

        if(document.readyState === 'complete' || document.readyState === 'interactive') init(); else document.addEventListener('DOMContentLoaded', init);
    })();
    (function(){
        'use strict';
        const ALLOWED_SCHEMES = ['http:', 'https:', 'mailto:', 'tel:'];

        function safeUrl(raw){
            if(!raw) return '#';
            const s = String(raw).trim();
            if(s === '') return '#';
            // Keep hash-only anchors
            if(s.startsWith('#')) return '#';
            try{
                const u = new URL(s, document.baseURI);
                if(!ALLOWED_SCHEMES.includes(u.protocol)) return '#';
                // remove potential embedded credentials
                u.username = '';
                u.password = '';
                // Return a normalized href provided by the URL API
                return u.href;
            }catch(e){
                return '#';
            }
        }

        function sanitizeAnchor(a){
            const orig = a.getAttribute('href');
            const safe = safeUrl(orig);
            if(!safe || safe === '#'){
                a.setAttribute('href','#');
                a.setAttribute('aria-disabled','true');
                a.classList.add('disabled-link');
                a.removeAttribute('target');
                return;
            }
            // Update to normalized URL
            a.setAttribute('href', safe);
            try{
                const parsed = new URL(safe, document.baseURI);
                if((parsed.protocol === 'http:' || parsed.protocol === 'https:') && parsed.origin !== location.origin){
                    // External link - open in new tab and harden rel
                    a.setAttribute('target','_blank');
                    const rel = (a.getAttribute('rel')||'').split(/\s+/).filter(Boolean);
                    ['noopener','noreferrer'].forEach(r=>{ if(!rel.includes(r)) rel.push(r); });
                    a.setAttribute('rel', rel.join(' ') );
                }
            }catch(e){}
        }

        function sanitizeIframe(iframe){
            const orig = iframe.getAttribute('src');
            const safe = safeUrl(orig);
            if(!safe || safe === '#'){
                iframe.removeAttribute('src');
                iframe.setAttribute('aria-hidden','true');
                return;
            }
            iframe.setAttribute('src', safe);
        }

        document.addEventListener('DOMContentLoaded', function(){
            document.querySelectorAll('a[href]').forEach(sanitizeAnchor);
            document.querySelectorAll('iframe[src]').forEach(sanitizeIframe);
        });
    })();
    </script>
    <script>
    (function(){
        // Client-side admin access: prompt for password, then try backend /admin/bookings?key= or fall back to localStorage
        const ADMIN_PASSWORD = 'MatkoMatko123'; // supplied by owner; used client-side for convenience
        const BOOKINGS_KEY = 'vb_bookings';

                function createModal(){
                        let m = document.getElementById('adminModal');
                        if(m) return m;
                        m = document.createElement('div');
                        m.id = 'adminModal';
                        Object.assign(m.style, {position:'fixed',inset:0,background:'rgba(0,0,0,0.6)',display:'flex',alignItems:'center',justifyContent:'center',zIndex:99999});
                        m.innerHTML = `<div style="background:#fff;padding:16px;border-radius:8px;max-width:1000px;width:95%;max-height:85%;overflow:auto;box-shadow:0 8px 30px rgba(0,0,0,0.3)">
                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                                    <h3 style="margin:0">Admin â€” Bookings</h3>
                                    <div style="display:flex;gap:8px;align-items:center">
                                        <button id="adminRefreshBtn" style="padding:6px 10px">Refresh</button>
                                        <button id="adminTimetableBtn" style="padding:6px 10px;background:#def;border:1px solid #89a">Open timetable</button>
                                        <button id="adminClearBtn" style="padding:6px 10px;background:#fdd;border:1px solid #c00">Clear bookings (local)</button>
                                        <button id="adminCloseBtn" style="padding:6px 10px">Close</button>
                                    </div>
                                </div>
                                <div id="adminContent">Loadingâ€¦</div>
                        </div>`;
                        document.body.appendChild(m);
                        document.getElementById('adminCloseBtn').addEventListener('click', ()=>{ m.remove(); });
                        // wire refresh and clear buttons
                        document.getElementById('adminRefreshBtn').addEventListener('click', async function(){
                                const content = m.querySelector('#adminContent');
                                content.innerHTML = '<p>Refreshingâ€¦</p>';
                                // attempt to refetch using stored admin key if present in session
                                const key = sessionStorage.getItem('vb_admin_key') || prompt('Admin key (leave blank to use last used):') || '';
                                if(key) sessionStorage.setItem('vb_admin_key', key);
                                try{ const list = await fetchAdminBookings(key); renderBookingsList(content, processAdminList(list)); }catch(e){ content.innerText = 'Refresh failed: ' + e; }
                        });
                        document.getElementById('adminClearBtn').addEventListener('click', function(){
                                if(!confirm('Clear all local bookings? This only affects localStorage backup.') ) return;
                                try{ localStorage.removeItem(BOOKINGS_KEY); const content = m.querySelector('#adminContent'); content.innerHTML = '<p style="text-align:center;padding:30px">No bookings</p>'; }catch(e){ alert('Clear failed: ' + e); }
                        });
                        document.getElementById('adminTimetableBtn').addEventListener('click', function(){
                            // ask for admin key to store for timetable page
                            const key = sessionStorage.getItem('vb_admin_key') || prompt('Admin key (leave blank to use stored):') || '';
                            if(key) sessionStorage.setItem('vb_admin_key', key);
                            window.open('timetable.html','_blank');
                        });
                        return m;
                }

        function processAdminList(list){
            if(!Array.isArray(list)) return [];
            // normalize and sort by checkin date ascending
            const normalized = list.map(b => ({
                id: b.id || '', room: b.room || '', checkin: b.checkin || '', checkout: b.checkout || '', name: b.name || '', email: b.email || '', guests: b.guests || '', phone: b.phone || '', createdAt: b.createdAt || ''
            }));
            normalized.sort((a,b)=>{
                const A = new Date(a.checkin).getTime() || 0;
                const B = new Date(b.checkin).getTime() || 0;
                return A - B;
            });
            return normalized;
        }

        function renderBookingsList(targetEl, list){
            if(!Array.isArray(list) || list.length===0){ targetEl.innerHTML = '<p style="text-align:center;padding:30px;font-weight:700;color:#666">No bookings</p>'; return; }
            const today = new Date();
            const rows = list.map(b=>{
                const checkoutDate = new Date(b.checkout);
                const isPast = !isNaN(checkoutDate) && (today > checkoutDate);
                const checkoutDisplay = isPast ? 'proÅ¡lo' : (b.checkout || '');
                // include data-booking-id on the row and an Actions column with a trash button
                return `<tr data-booking-id="${escapeHtml(b.id)}" style="border-bottom:1px solid #eee"><td style="padding:8px">${escapeHtml(b.id)}</td><td style="padding:8px">${escapeHtml(b.room)}</td><td style="padding:8px">${escapeHtml(formatDateSimple(b.checkin))}</td><td style="padding:8px">${escapeHtml(checkoutDisplay)}</td><td style="padding:8px">${escapeHtml(b.name)}</td><td style="padding:8px">${escapeHtml(b.email)}</td><td style="padding:8px">${escapeHtml(b.guests)}</td><td style="padding:8px">${escapeHtml(b.phone)}</td><td style="padding:8px">${escapeHtml(formatDateSimple(b.createdAt))}</td><td style="padding:8px"><button class="admin-delete" data-id="${escapeHtml(b.id)}" style="padding:6px;border-radius:4px;border:1px solid #c33;background:#fee;color:#900;cursor:pointer">ðŸ—‘ Delete</button></td></tr>`;
            }).join('');
            targetEl.innerHTML = `<div style="max-height:60vh;overflow:auto;border:1px solid #ddd;border-radius:6px"><table id="adminBookingTable" style="width:100%;border-collapse:collapse;font-family:sans-serif"><thead style="position:sticky;top:0;background:#fafafa;border-bottom:2px solid #ddd"><tr><th style="text-align:left;padding:10px">ID</th><th style="text-align:left;padding:10px">Room</th><th style="text-align:left;padding:10px">Check-in</th><th style="text-align:left;padding:10px">Check-out</th><th style="text-align:left;padding:10px">Name</th><th style="text-align:left;padding:10px">Email</th><th style="text-align:left;padding:10px">Guests</th><th style="text-align:left;padding:10px">Phone</th><th style="text-align:left;padding:10px">Created</th><th style="text-align:left;padding:10px">Actions</th></tr></thead><tbody>${rows}</tbody></table></div>`;
            // add right-click delete handler on table rows
            try{
                const table = document.getElementById('adminBookingTable');
                if(table){
                    // contextmenu delete for power-users
                    table.addEventListener('contextmenu', async function(ev){
                        ev.preventDefault();
                        let tr = ev.target.closest('tr');
                        if(!tr) return;
                        const id = tr.getAttribute('data-booking-id');
                        if(!id) return;
                        if(!confirm('Delete booking ' + id + '?')) return;
                        await performAdminDelete(id, tr);
                    });
                    // click handler for trash buttons
                    table.addEventListener('click', async function(ev){
                        const btn = ev.target.closest && ev.target.closest('.admin-delete');
                        if(!btn) return;
                        const id = btn.getAttribute('data-id');
                        if(!id) return;
                        if(!confirm('Delete booking ' + id + '?')) return;
                        // find the row
                        const tr = btn.closest('tr');
                        await performAdminDelete(id, tr);
                    });
                }
            }catch(e){ console.warn('attach delete handler failed', e); }
        }

        async function performAdminDelete(id, tr){
            // try server delete with admin key if available
            const adminKey = sessionStorage.getItem('vb_admin_key') || '';
            try{
                const url = '/api/bookings/' + encodeURIComponent(id) + (adminKey ? ('?key=' + encodeURIComponent(adminKey)) : '');
                const res = await fetch(url, { method: 'DELETE', headers: adminKey ? { 'x-admin-key': adminKey } : {} });
                if(res.ok){
                    // remove from local cache if present
                    try{
                        const raw = localStorage.getItem(BOOKINGS_KEY);
                        const arr = raw ? JSON.parse(raw) : [];
                        const remaining = (arr||[]).filter(b => String(b.id) !== String(id));
                        localStorage.setItem(BOOKINGS_KEY, JSON.stringify(remaining));
                    }catch(e){ /* ignore local removal errors */ }
                    if(tr) tr.remove(); alert('Deleted ' + id);
                    try{ renderAvailability($('c_room') && $('c_room').value); }catch(e){}
                    return;
                }
            }catch(e){ /* continue to local delete */ }
            // fallback: remove from localStorage
            try{
                const raw = localStorage.getItem(BOOKINGS_KEY); const arr = raw ? JSON.parse(raw) : [];
                const remaining = (arr||[]).filter(b => String(b.id) !== String(id));
                localStorage.setItem(BOOKINGS_KEY, JSON.stringify(remaining));
                if(tr) tr.remove(); alert('Deleted locally: ' + id);
                try{ renderAvailability($('c_room') && $('c_room').value); }catch(e){}
            }catch(e){ alert('Delete failed: ' + e); }
        }

        function formatDateSimple(d){ try{ const dt = new Date(d); if(isNaN(dt)) return d || ''; return dt.toISOString().slice(0,10); }catch(e){ return d||''; } }

        function escapeHtml(s){ if(s === null || s === undefined) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

        async function fetchAdminBookings(password){
            // Try backend first (if available)
            try{
                // prefer explicit admin endpoint
                const url = '/admin/bookings?key=' + encodeURIComponent(password);
                const res = await fetch(url, { method: 'GET' });
                if(res.ok){
                    const data = await res.json();
                    return Array.isArray(data) ? data : [];
                }
            }catch(e){}
            // fallback to localStorage
            try{
                const raw = localStorage.getItem(BOOKINGS_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr : [];
            }catch(e){ return []; }
        }

        document.addEventListener('click', function(ev){
            if(!ev.target) return;
            if(ev.target.id === 'adminAccessBtn'){
                // only allow after sign-in? we still require password
                const pwd = prompt('Admin password:');
                if(!pwd) return alert('Password required');
                // basic client-side password check for local admin access
                if(pwd !== ADMIN_PASSWORD){ return alert('Incorrect admin password'); }
                const modal = createModal();
                const content = modal.querySelector('#adminContent');
                content.innerHTML = '<p>Loading bookingsâ€¦</p>';
                // If password matches client-side constant, use it to fetch backend; otherwise still attempt fetch with provided pwd
                const usePwd = pwd;
                fetchAdminBookings(usePwd).then(list=>{
                    const processed = processAdminList(list);
                    renderBookingsList(content, processed);
                }).catch(err=>{ content.innerText = 'Error loading bookings: ' + err; });
            }
        });
    })();
    </script>
    <!-- Load flatpickr JS (provides consistent date picker UI on browsers without native pickers) -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <!-- Contact form behaviour: persist to localStorage and open mail client -->
    <script>
    (function(){
        'use strict';
            const STORAGE_KEY = 'vb_contact_form';
        const OWNER_EMAIL = 'prodragonno1@gmail.com';
        // bookings stored locally for demo: array of {id, room, checkin, checkout, name, email, guests, phone, createdAt}
        const BOOKINGS_KEY = 'vb_bookings';
        
        // ===== GOOGLE SHEETS CONFIGURATION =====
        // To enable cross-device syncing, set up a Google Sheet with this structure:
        // - Column A: room
        // - Column B: checkin (YYYY-MM-DD format)
        // - Column C: checkout (YYYY-MM-DD format)
        // - Column D: name
        // - Column E: email
        // - Column F: guests
        // - Column G: phone
        // - Column H: createdAt (ISO timestamp)
        // - Column I: id (BKG-timestamp)
        //
        // Then share the sheet publicly (View access) and paste the SHEET_ID below.
        // You can also use this public Google Apps Script endpoint if set up:
        const GOOGLE_SHEET_ID = ''; // Leave empty to use localStorage only
        const GOOGLE_APPS_SCRIPT_URL = ''; // If using Google Apps Script as backend
        
        // ===== BACKEND API CONFIGURATION =====
        // For cross-device syncing, use a backend server.
        // Options:
        // 1. Local Node.js: http://localhost:3000 (run: node backend.js)
        // 2. Deployed server: https://your-villa-api.herokuapp.com or similar
        // 3. Firebase: https://your-project.cloudfunctions.net/bookings
        // 4. Google Apps Script: https://script.google.com/macros/d/.../usercontent
        //
        // Leave empty to use localStorage only (bookings won't sync across devices)
    const ACTIVE_BACKEND_URL = 'https://script.google.com/macros/s/AKfycbyooPSSSEdTmouKNv6X1R5NtypwFfTcmCGGohyivMRWrbX1e03tRGs4k2qkGt6FL7uw/exec';
        // Quick backend health check (non-blocking). Logs result to console to help debugging CORS/deploy issues.
        if(ACTIVE_BACKEND_URL){
            console.log('ACTIVE_BACKEND_URL:', ACTIVE_BACKEND_URL);
            setTimeout(async function(){
                try{
                    const healthUrl = ACTIVE_BACKEND_URL.includes('/exec') ? (ACTIVE_BACKEND_URL + '?action=health') : (ACTIVE_BACKEND_URL + '/api/bookings?action=health');
                    const res = await fetch(healthUrl, { method: 'GET', headers: { 'Accept': 'application/json' }});
                    if(res.ok){
                        try{ const body = await res.json(); console.log('Backend health OK:', body); }
                        catch(e){ const txt = await res.text(); console.log('Backend health OK (text):', txt); }
                    } else {
                        const txt = await res.text(); console.warn('Backend health HTTP', res.status, txt);
                    }
                }catch(err){
                    console.warn('Backend health check failed (network/CORS):', err);
                }
            }, 500);
        } else {
            console.log('No ACTIVE_BACKEND_URL configured; bookings will use localStorage only.');
        }
        function $(id){ return document.getElementById(id); }

        // Debug: Log when script loads
        console.log('Villa BraÅ¡ina booking script loaded');
        console.log('contactForm element:', $('contactForm'));

            function loadForm(){
                /*
                    Reset behavior: clear any previously saved data and start with an empty form.
                    This ensures a page reload always shows empty fields.
                */
                try{
                    // Remove saved item if present
                    try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
                    // Clear visible inputs
                    if($('c_name')) $('c_name').value = '';
                    if($('c_email')) $('c_email').value = '';
                    if($('c_phone')) $('c_phone').value = '';
                    if($('c_room')) $('c_room').value = '';
                    if($('c_checkin')) $('c_checkin').value = '';
                    if($('c_checkout')) $('c_checkout').value = '';
                    if($('c_guests')) {
                        $('c_guests').value = '0';
                        // Reset min/max to sensible defaults
                        $('c_guests').min = $('c_guests').getAttribute('min') || '0';
                        $('c_guests').max = $('c_guests').getAttribute('max') || '4';
                    }
                    // Ensure date and guests containers are hidden
                    const df = document.getElementById('dateFields');
                    const gf = document.getElementById('guestsField');
                    if(df) df.style.display = 'none';
                    if(gf) gf.style.display = 'none';
                }catch(e){ /* ignore errors */ }
            }

        function saveForm(){
            const data = {
                name: $('c_name').value || '',
                email: $('c_email').value || '',
                phone: $('c_phone').value || '',
                room: $('c_room').value || '',
                checkin: $('c_checkin').value || '',
                checkout: $('c_checkout').value || '',
                guests: $('c_guests').value || ''
            };
            try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }catch(e){}
            $('contactStatus').textContent = 'Saved locally.';
            setTimeout(()=>{$('contactStatus').textContent='';},2500);
        }

        // Enhanced booking storage: localStorage with sync to backend
        async function loadBookings(){
            // If backend is configured, try to use it
            if(ACTIVE_BACKEND_URL){
                try{
                    // For Google Apps Script, use direct URL with action parameter
                    const url = ACTIVE_BACKEND_URL.includes('/exec') 
                        ? ACTIVE_BACKEND_URL + '?action=getBookings'
                        : ACTIVE_BACKEND_URL + '/api/bookings';
                    
                    const response = await fetch(url, { 
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    if(response.ok){
                        let bookings = await response.json();
                        // If backend returned an error object, don't overwrite local cache â€” use local cache instead
                        if(bookings && bookings.error){
                            console.warn('Backend returned error object, skipping remote cache and using local cache:', bookings);
                            try{ const rawLocal = localStorage.getItem(BOOKINGS_KEY); let local = rawLocal ? JSON.parse(rawLocal) : []; if(Array.isArray(local)) return local; }catch(e){}
                            return [];
                        }
                        // Ensure it's an array (Apps Script may return {bookings: [...]})
                        if(!Array.isArray(bookings)){
                            if(bookings && Array.isArray(bookings.bookings)){
                                bookings = bookings.bookings;
                            } else {
                                console.warn('Backend returned non-array:', bookings);
                                // fall back to local cache instead of overwriting it
                                try{ const rawLocal = localStorage.getItem(BOOKINGS_KEY); let local = rawLocal ? JSON.parse(rawLocal) : []; if(Array.isArray(local)) return local; }catch(e){}
                                bookings = [];
                            }
                        }
                        // Cache in localStorage as backup
                        try{ localStorage.setItem(BOOKINGS_KEY, JSON.stringify(bookings)); }catch(e){}
                        return bookings;
                    } else {
                        console.log('Backend HTTP error:', response.status);
                    }
                }catch(e){
                    console.log('Backend unavailable, using localStorage:', e.message);
                }
            }
            
            // Fallback to localStorage
            try{ 
                const raw = localStorage.getItem(BOOKINGS_KEY); 
                let bookings = raw ? JSON.parse(raw) : []; 
                if(!Array.isArray(bookings)) bookings = [];
                return bookings;
            }catch(e){ 
                console.log('localStorage parse error:', e);
                return []; 
            }
        }

        // Public-only bookings loader: returns only non-personal fields so it can be used
        // by public availability calendars without exposing guest information.
        async function loadPublicBookings(){
            // Try backend public endpoint first
            if(ACTIVE_BACKEND_URL){
                try{
                    // Apps Script-style exec endpoints typically don't provide /api paths.
                    const publicUrl = ACTIVE_BACKEND_URL.includes('/exec')
                        ? (ACTIVE_BACKEND_URL + (ACTIVE_BACKEND_URL.includes('?') ? '&' : '?') + 'public=1')
                        : (ACTIVE_BACKEND_URL.replace(/\/$/, '') + '/api/bookings?public=1');

                    const res = await fetch(publicUrl, { method: 'GET', headers: { 'Accept': 'application/json' }});
                    if(res.ok){
                        try{ const body = await res.json();
                            // Ensure reduced shape: map if necessary
                            if(Array.isArray(body)) return body.map(b => ({ id: b.id, room: b.room, checkin: b.checkin, checkout: b.checkout, createdAt: b.createdAt }));
                        }catch(e){ /* ignore parse */ }
                    }
                }catch(e){ console.warn('loadPublicBookings backend fetch failed:', e); }
            }

            // Fallback to local cache (strip personal fields)
            try{
                const raw = localStorage.getItem(BOOKINGS_KEY);
                let bookings = raw ? JSON.parse(raw) : [];
                if(!Array.isArray(bookings)) bookings = [];
                return bookings.map(b => ({ id: b.id, room: b.room, checkin: b.checkin, checkout: b.checkout, createdAt: b.createdAt }));
            }catch(e){ console.warn('loadPublicBookings local fallback failed:', e); return []; }
        }
        
        async function saveBookings(bookings){ 
            // Always save to localStorage as backup
            try{
                if(!Array.isArray(bookings)){
                    console.warn('saveBookings called with non-array, skipping local cache write:', bookings);
                } else {
                    localStorage.setItem(BOOKINGS_KEY, JSON.stringify(bookings));
                }
            }catch(e){
                console.error('Failed to save to localStorage:', e);
            }
            
            // If backend is configured, sync to it
            if(ACTIVE_BACKEND_URL){
                try{
                    const url = ACTIVE_BACKEND_URL.includes('/exec')
                        ? ACTIVE_BACKEND_URL
                        : ACTIVE_BACKEND_URL + '/api/bookings';
                    
                    await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(bookings)
                    }).catch(e => console.log('Backend sync attempted'));
                }catch(e){
                    console.log('Backend sync not available');
                }
            }
        }
        
        async function addBooking(booking){
            // If backend is configured, use it
            if(ACTIVE_BACKEND_URL){
                try{
                    const url = ACTIVE_BACKEND_URL.includes('/exec')
                        ? ACTIVE_BACKEND_URL
                        : ACTIVE_BACKEND_URL + '/api/bookings';
                    
                    console.log('Sending booking to backend (XHR):', url, booking);
                    try{
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(booking)
                        });

                        console.log('Backend response status:', response.status);

                        if(response.ok){
                            const text = await response.text();
                            let saved;
                            try{ saved = text ? JSON.parse(text) : null; }catch(e){
                                console.warn('Could not parse backend response as JSON, using raw text:', e);
                                saved = text;
                            }
                            console.log('Backend saved booking (raw):', saved);
                            if(saved && typeof saved === 'object' && saved.error){
                                console.warn('Backend reported error:', saved.error);
                                // fall through to fallback logic
                            } else {
                                try{ const all = await loadBookings(); await saveBookings(all); }catch(e){ console.warn('Could not refresh local cache from backend:', e); }
                                return saved;
                            }
                        } else {
                            const errorText = await response.text();
                            console.log('Backend error response:', response.status, errorText);
                        }
                    }catch(err){
                        // Likely a CORS/network error. Try iframe form POST fallback.
                        console.warn('Backend XHR failed, attempting form POST fallback:', err);
                        try{
                            if(ACTIVE_BACKEND_URL){
                                attemptFormPostBooking(ACTIVE_BACKEND_URL, booking);
                                // Don't wait for response (iframe won't expose it). Continue and fallback to localStorage.
                            }
                        }catch(e){ console.warn('Form-post fallback failed:', e); }
                    }
                }catch(e){
                    console.log('Backend fetch error, will use localStorage:', e.message);
                    // Fall through to localStorage backup
                }
            }
            
            // Fallback: add to localStorage
            console.log('Using localStorage fallback for booking');
            let bookings = await loadBookings();
            // Ensure bookings is an array
            if(!Array.isArray(bookings)){
                console.warn('loadBookings did not return an array, resetting to empty:', bookings);
                bookings = [];
            }
            bookings.push(booking);
            await saveBookings(bookings);
            console.log('Booking saved to localStorage:', booking);
            return booking;
        }

        // Helper: attempt to POST booking via a hidden form + iframe (used when XHR is blocked by CORS)
        function attemptFormPostBooking(url, booking){
            try{
                const iframeName = 'vb_form_target_' + Date.now();
                const iframe = document.createElement('iframe');
                iframe.name = iframeName;
                iframe.style.display = 'none';
                document.body.appendChild(iframe);

                const form = document.createElement('form');
                form.method = 'POST';
                form.action = url;
                form.target = iframeName;
                form.style.display = 'none';

                // Populate form fields
                const fields = ['id','room','checkin','checkout','name','email','guests','phone','createdAt'];
                fields.forEach(k=>{
                    const inp = document.createElement('input');
                    inp.type = 'hidden';
                    inp.name = k;
                    inp.value = booking[k] || '';
                    form.appendChild(inp);
                });

                document.body.appendChild(form);
                form.submit();

                // Clean-up after a short delay
                setTimeout(()=>{ try{ document.body.removeChild(form); document.body.removeChild(iframe); }catch(e){} }, 5000);
                console.log('Form-post fallback submitted to', url);
            }catch(e){ console.warn('attemptFormPostBooking error:', e); }
        }

        // All event handlers attached to the original DOMContentLoaded from line 283
        // The second DOMContentLoaded has been removed because it never fires
        // (once the first DOMContentLoaded finishes, the event already passed)
            
            // ===== ADMIN RESET PANEL =====
            // Hidden reset panel triggered by Ctrl+Shift+R for easy testing
            document.addEventListener('keydown', function(ev){
                if(ev.ctrlKey && ev.shiftKey && ev.key === 'R'){
                    ev.preventDefault();
                    const modal = $('adminResetModal');
                    if(modal) modal.classList.toggle('show');
                }
            });
            
            if($('confirmResetBtn')){
                $('confirmResetBtn').addEventListener('click', async function(){
                    // Clear all bookings from localStorage and backend
                    try{
                        await saveBookings([]);
                        localStorage.setItem(BOOKINGS_KEY, JSON.stringify([]));
                    }catch(e){ console.log('Reset error', e); }
                    
                    // Refresh availability calendars
                    const room = $('c_room') && $('c_room').value;
                    if(room){
                        try{ renderAvailability(room); }catch(e){}
                    }
                    
                    // Show confirmation
                    alert('âœ“ All bookings cleared. Calendars refreshed.');
                    
                    // Close modal
                    const modal = $('adminResetModal');
                    if(modal) modal.classList.remove('show');
                });
            }
            
            if($('cancelResetBtn')){
                $('cancelResetBtn').addEventListener('click', function(){
                    const modal = $('adminResetModal');
                    if(modal) modal.classList.remove('show');
                });
            }
            
            // Close modal if user clicks outside (on the dark overlay)
            const modal = $('adminResetModal');
            if(modal){
                modal.addEventListener('click', function(ev){
                    if(ev.target === this){
                        this.classList.remove('show');
                    }
                });
            }
            
            // Initialize flatpickr date pickers for consistent UI across browsers
            try{
                if(window.flatpickr){
                    // Enforce booking window: from May 1 to Oct 31 each year
                    function bookingWindowForYear(year){
                        const min = new Date(year, 4, 1); // 4 = May (1st)
                        const max = new Date(year, 9, 31); // 9 = October (31st)
                        return { min, max };
                    }

                    const today = new Date();
                    const thisYearWindow = bookingWindowForYear(today.getFullYear());
                    // If today is after max, fallback to next year's window
                    let minDate = thisYearWindow.min;
                    let maxDate = thisYearWindow.max;
                    if(today > thisYearWindow.max){
                        const next = bookingWindowForYear(today.getFullYear() + 1);
                        minDate = next.min; maxDate = next.max;
                    }
                    // Also ensure dates are not earlier than today
                    if(minDate < new Date()) minDate = new Date();

                    const fpOptions = {
                        altInput: true,
                        altFormat: "d.m.Y",
                        dateFormat: "Y-m-d",
                        allowInput: true,
                        minDate: minDate,
                        maxDate: maxDate,
                        onChange: function(selectedDates, dateStr, instance){
                            try{ calculatePrice(); }catch(e){}
                            try{ renderSelectedRangeStatus(); }catch(e){}
                        }
                    };
                    try{ window.checkinFp = flatpickr('#c_checkin', fpOptions); }catch(e){}
                    try{ window.checkoutFp = flatpickr('#c_checkout', fpOptions); }catch(e){}
                }
            }catch(e){ /* ignore if flatpickr not loaded */ }
            
            // Poll for booking updates from other devices (if backend configured)
            // Check every 5 seconds if new bookings arrived
            if(ACTIVE_BACKEND_URL){
                setInterval(async function(){
                    const room = $('c_room') && $('c_room').value;
                    if(room){
                        // Silently refresh availability status if dates are selected
                        const checkin = $('c_checkin') && $('c_checkin').value;
                        const checkout = $('c_checkout') && $('c_checkout').value;
                        if(checkin && checkout){
                            renderSelectedRangeStatus();
                        }
                    }
                }, 5000); // Poll every 5 seconds
            }

            // Show/hide date fields and guests field based on room selection
            let estimatedTotal = null;
            function calculatePrice(){
                const priceDisplay = $('priceDisplay');
                estimatedTotal = null;
                if(!$('c_room')) return;
                const roomSel = $('c_room');
                const selected = roomSel.options[roomSel.selectedIndex];
                if(!selected || roomSel.value === ''){
                    if(priceDisplay) priceDisplay.style.display = 'none';
                    return;
                }
                const pricePerNight = parseFloat(selected.dataset.price || selected.getAttribute('data-price') || 0);
                const checkin = $('c_checkin').value;
                const checkout = $('c_checkout').value;
                if(!checkin || !checkout){
                    if(priceDisplay){ priceDisplay.textContent = 'Select check-in and check-out to see price.'; priceDisplay.style.display = 'block'; }
                    return;
                }
                const d1 = new Date(checkin);
                const d2 = new Date(checkout);
                const nights = Math.floor((d2 - d1) / (1000*60*60*24));
                if(isNaN(nights) || nights <= 0){
                    if(priceDisplay){ priceDisplay.textContent = 'Check-out must be after check-in to calculate price.'; priceDisplay.style.display = 'block'; }
                    return;
                }
                const total = nights * pricePerNight;
                estimatedTotal = total;
                if(priceDisplay){
                    priceDisplay.textContent = `Estimated total: â‚¬${total} (${nights} nights Ã— â‚¬${pricePerNight}/night)`;
                    priceDisplay.style.display = 'block';
                }
            }

            $('c_room').addEventListener('change', function(){
                const dateFields = $('dateFields');
                const guestsField = $('guestsField');
                const hasRoom = this.value !== '';
                
                // Toggle visibility
                if(dateFields) dateFields.style.display = hasRoom ? 'block' : 'none';
                if(guestsField) guestsField.style.display = hasRoom ? 'block' : 'none';
                
                // JavaScript validation will check these fields - no need to set required dynamically
                
                // Update max guests based on selected room
                if(hasRoom) {
                    const selectedOption = this.options[this.selectedIndex];
                    const maxGuests = selectedOption.textContent.match(/max guests (\d+)/);
                    if(maxGuests) {
                        const maxGuestsNum = parseInt(maxGuests[1]);
                        const guestsInput = $('c_guests');
                        if(guestsInput){
                            guestsInput.max = maxGuestsNum;
                            guestsInput.value = Math.min(Number(guestsInput.value||0), maxGuestsNum);
                            // Update the label to show current max
                            const guestsLabel = guestsInput.previousElementSibling;
                            if(guestsLabel) guestsLabel.textContent = `Number of guests (max ${maxGuestsNum})`;
                        }
                    }
                    // recalculate price when a room is chosen
                    calculatePrice();
                } else {
                    // Clear fields if no room selected
                    if($('c_checkin')) $('c_checkin').value = '';
                    if($('c_checkout')) $('c_checkout').value = '';
                    if($('c_guests')) $('c_guests').value = '0'; // Reset to zero
                    if($('c_guests')) $('c_guests').max = 1; // Reset max
                    if($('c_guests')){
                        const lbl = $('c_guests').previousElementSibling; if(lbl) lbl.textContent = 'Number of guests';
                    }
                    // hide price
                    const pd = $('priceDisplay'); if(pd) pd.style.display = 'none';
                }
            });

            // recalculate when dates change
            if($('c_checkin')) $('c_checkin').addEventListener('change', calculatePrice);
            if($('c_checkout')) $('c_checkout').addEventListener('change', calculatePrice);

            // --- Gallery per-room placeholders (set in code only) ---
            const galleryEl = document.getElementById('gallery');
            const galleryTitle = document.getElementById('galleryTitle');
            const roomPhotoControls = document.getElementById('roomPhotoControls');
            const roomPhotosInput = document.getElementById('roomPhotosInput');
            const clearRoomPhotosBtn = document.getElementById('clearRoomPhotos');
            const roomPlaceholderControls = document.getElementById('roomPlaceholderControls');
            const placeholderFilesInput = document.getElementById('placeholderFilesInput');
            const savePlaceholdersBtn = document.getElementById('savePlaceholdersBtn');
            const clearPlaceholdersBtn = document.getElementById('clearPlaceholdersBtn');
            const PLACEHOLDER_KEY = 'vb_room_placeholders';
            let savedPlaceholders = {};
            try{
                const raw = localStorage.getItem(PLACEHOLDER_KEY);
                if(raw) savedPlaceholders = JSON.parse(raw) || {};
            }catch(e){ savedPlaceholders = {}; }

            // base placeholder images (hard-coded per room)
            // Edit these arrays in the source to change placeholders â€” only via code changes (no UI uploads)
            const roomPlaceholders = {
                0: ['163596029.jpg','163613119.jpg','preuzmi.jpg'],
                1: ['254124820.jpg','167775789.jpg','167775776.jpg'],
                2: ['163596176.webp','163613119.jpg','preuzmi.jpg'],
                3: ['167774122.jpg','163596176.webp','preuzmi.jpg'],
                4: ['163596029.jpg','163613119.jpg','preuzmi.jpg'],
                5: ['preuzmi.jpg','163596176.webp','167774122.jpg'],
                6: ['167774122.jpg','preuzmi.jpg','163596176.webp'],
                7: ['163596176.webp','preuzmi.jpg','167774122.jpg'],
                8: ['preuzmi.jpg','167774122.jpg','163596176.webp'],
                9: ['167774122.jpg','163596176.webp','preuzmi.jpg'],
                10: ['163596176.webp','167774122.jpg','preuzmi.jpg'],
                11: ['preuzmi.jpg','163596176.webp','167774122.jpg'],
                12: ['167774122.jpg','preuzmi.jpg','163596176.webp'],
                13: ['163596176.webp','167774122.jpg','preuzmi.jpg'],
                14: ['preuzmi.jpg','167774122.jpg','163596176.webp'],
                15: ['167774122.jpg','163596176.webp','preuzmi.jpg']
            };

            // runtime storage for user-uploaded previews (dataURLs) and temp buffer
            const uploadedPhotos = {}; // keyed by room value (string)
            let placeholderBuffer = null;

            // baseImgs used as ultimate fallback when specific slot is empty
            const baseImgs = roomPlaceholders[0].slice();

            function normalizeRoomKey(room){
                // room may be numeric or string; we keep keys as strings for uploaded/saved placeholders
                if(room === null || room === undefined || room === '') return null;
                return String(room);
            }

            function renderGallery(room){
                if(!galleryEl) return;
                const roomKey = normalizeRoomKey(room);

                let images = [];
                if(!roomKey){
                    if(galleryTitle) galleryTitle.textContent = 'Gallery';
                    images = roomPlaceholders[0].slice(0,3);
                    if(roomPhotoControls) roomPhotoControls.style.display = 'none';
                    if(roomPlaceholderControls) roomPlaceholderControls.style.display = 'none';
                } else {
                    if(galleryTitle) galleryTitle.textContent = 'Room ' + roomKey;
                    // Priority: uploadedPhotos -> savedPlaceholders -> roomPlaceholders -> default
                    images = (uploadedPhotos[roomKey] && uploadedPhotos[roomKey].slice(0,3))
                        || (savedPlaceholders[roomKey] && savedPlaceholders[roomKey].slice(0,3))
                        || (roomPlaceholders[Number(roomKey)] && roomPlaceholders[Number(roomKey)].slice(0,3))
                        || roomPlaceholders[0].slice(0,3);
                    if(roomPhotoControls) roomPhotoControls.style.display = 'block';
                    if(roomPlaceholderControls) roomPlaceholderControls.style.display = 'block';
                }

                // Ensure we always have 3 slots and replace empty values with fallbacks
                const slots = 3;
                let html = '';
                for(let i=0;i<slots;i++){
                    let src = images[i] || baseImgs[i % baseImgs.length] || '';
                    // If src is empty string, fall back to next available from baseImgs
                    if(!src) src = baseImgs[i % baseImgs.length] || '';
                    // avoid injecting literal 'undefined' or empty values
                    const safeSrc = src || '';
                    html += `<img loading="lazy" src="${encodeURI(safeSrc)}" alt="gallery image ${i+1}">`;
                }
                galleryEl.innerHTML = html;
            }

            if($('c_room')){
                $('c_room').addEventListener('change', function(){
                    renderGallery(this.value || null);
                    renderAvailability(this.value || null);
                    renderSelectedRangeStatus();
                });
            }

            // Booking helpers (localStorage-backed demo)
            // loadBookings (async) and saveBookings (async) are defined earlier and may contact backend.
            // Provide a safe, synchronous local-only loader to read cached bookings quickly.
            function loadBookingsLocal(){
                try{
                    const raw = localStorage.getItem(BOOKINGS_KEY);
                    let parsed = raw ? JSON.parse(raw) : [];
                    if(!Array.isArray(parsed)){
                        console.warn('loadBookingsLocal found non-array in localStorage, coercing to []:', parsed);
                        parsed = [];
                    }
                    return parsed;
                }catch(e){
                    console.warn('loadBookingsLocal localStorage parse error, returning empty array:', e);
                    return [];
                }
            }

            function getBookingsForRoom(room){ if(!room) return []; const all = loadBookingsLocal(); return (all||[]).filter(b => String(b.room) === String(room)); }
            
            // Async version for use in async contexts that prefer fresh backend data
            async function getBookingsForRoomAsync(room){ 
                if(!room) return []; 
                const all = await loadBookings(); 
                return (all||[]).filter(b => String(b.room) === String(room)); 
            }
            function formatDate(d){ try{ const dt = new Date(d); if(isNaN(dt)) return d; return dt.toISOString().slice(0,10); }catch(e){ return d; } }
            
            // Check if date ranges overlap - treats ranges as [start, end) - end not included
            // This checks that NO day between aStart and aEnd conflicts with bStart to bEnd
            function rangesOverlap(aStart,aEnd,bStart,bEnd){
                const A = new Date(aStart).getTime();
                const B = new Date(aEnd).getTime();
                const C = new Date(bStart).getTime();
                const D = new Date(bEnd).getTime();
                if(isNaN(A) || isNaN(B) || isNaN(C) || isNaN(D)) return false;
                // Two ranges overlap if: start1 < end2 AND start2 < end1
                return (A < D) && (C < B);
            }

            // Render availability for selected room by updating the existing check-in/check-out pickers
            // Booked nights (checkin inclusive to checkout exclusive) are supplied as disabled ranges
            async function renderAvailability(room){
                // If no room selected, clear disabled ranges
                if(!room){
                    try{
                        if(window.checkinFp){ window.checkinFp.set('disable', []); window.checkinFp.redraw(); }
                        if(window.checkoutFp){ window.checkoutFp.set('disable', []); window.checkoutFp.redraw(); }
                    }catch(e){}
                    return;
                }

                // Collect bookings: prefer local cache first for immediate availability UI,
                // then try remote public backend for fresh data (public-only; no guest info returned).
                let local = loadBookingsLocal();
                let all = Array.isArray(local) ? local : [];
                try{
                    const remote = await loadPublicBookings();
                    if(Array.isArray(remote) && remote.length > 0){
                        all = remote;
                    } else {
                        console.log('renderAvailability: remote returned empty or non-array, keeping local cache with', (all||[]).length, 'items');
                    }
                }catch(e){
                    console.warn('renderAvailability: loadPublicBookings threw, using local cache:', e);
                }

                if(!Array.isArray(all)){
                    console.warn('renderAvailability expected array but got:', all);
                    // try to coerce if it looks like an object with bookings property
                    if(all && Array.isArray(all.bookings)) all = all.bookings;
                    else all = [];
                }

                const roomBookings = (all || []).filter(b => String(b.room) === String(room));
                console.log('renderAvailability - room:', room, 'totalBookings:', (all||[]).length, 'roomBookings:', roomBookings.length, roomBookings);

                // Build disable ranges: from checkin (inclusive) to day before checkout (inclusive)
                const disableRanges = roomBookings.map(b=>{
                    try{
                        const from = new Date(b.checkin);
                        const to = new Date(b.checkout);
                        to.setDate(to.getDate() - 1);
                        return { from: from, to: to };
                    }catch(e){ return null; }
                }).filter(Boolean);

                // If flatpickr instances exist on the date inputs, update them
                if(window.checkinFp){
                    try{ console.log('renderAvailability - setting checkinFp disableRanges:', disableRanges); window.checkinFp.set('disable', disableRanges); window.checkinFp.redraw(); }catch(e){ console.warn('renderAvailability error setting checkinFp:', e); }
                }
                if(window.checkoutFp){
                    try{ console.log('renderAvailability - setting checkoutFp disableRanges:', disableRanges); window.checkoutFp.set('disable', disableRanges); window.checkoutFp.redraw(); }catch(e){ console.warn('renderAvailability error setting checkoutFp:', e); }
                }
            }

            // When user picks dates, show simple FREE or NOT FREE status
            function renderSelectedRangeStatus(){
                const room = $('c_room') && $('c_room').value;
                const checkin = $('c_checkin') && $('c_checkin').value;
                const checkout = $('c_checkout') && $('c_checkout').value;
                const status = $('availabilityStatus');
                
                if(!room || !checkin || !checkout){ 
                    if(status) status.textContent = '';
                    return; 
                }
                
                // Check if these dates conflict with any existing booking
                const bookings = getBookingsForRoom(room);
                const conflict = bookings.some(b => rangesOverlap(b.checkin, b.checkout, checkin, checkout));
                
                if(conflict){
                    if(status) { 
                        status.textContent = 'âŒ Not free â€” these dates conflict with an existing booking.'; 
                        status.style.color = '#c00'; 
                    }
                } else {
                    if(status) { 
                        status.textContent = 'âœ“ Free â€” these dates are available.'; 
                        status.style.color = '#064'; 
                    }
                }
            }

            // Attempt to sync locally-saved bookings to the backend.
            async function syncBookings(){
                const statusEl = document.getElementById('syncStatus');
                try{
                    let raw = localStorage.getItem(BOOKINGS_KEY);
                    let bookings = raw ? JSON.parse(raw) : [];
                    if(!Array.isArray(bookings) || bookings.length === 0){
                        if(statusEl) statusEl.textContent = 'No local bookings to sync.';
                        return;
                    }
                    if(statusEl) statusEl.textContent = 'Syncing ' + bookings.length + ' booking(s)...';

                    const remaining = [];
                    for(const b of bookings){
                        try{
                            const ok = await attemptSyncBooking(b);
                            if(!ok){
                                remaining.push(b);
                            }
                        }catch(e){
                            console.warn('syncBooking error for', b, e);
                            remaining.push(b);
                        }
                    }

                    if(remaining.length === 0){
                        localStorage.removeItem(BOOKINGS_KEY);
                        if(statusEl) statusEl.textContent = 'All bookings synced.';
                    } else {
                        try{ localStorage.setItem(BOOKINGS_KEY, JSON.stringify(remaining)); }catch(e){}
                        if(statusEl) statusEl.textContent = remaining.length + ' booking(s) pending.';
                    }
                }catch(e){
                    console.error('syncBookings failed:', e);
                    if(statusEl) statusEl.textContent = 'Sync failed: ' + (e && e.message ? e.message : String(e));
                }
                setTimeout(()=>{ if(statusEl) statusEl.textContent = ''; }, 5000);
            }

            // Try to send a single booking to backend. Returns true if considered synced.
            async function attemptSyncBooking(booking){
                if(!ACTIVE_BACKEND_URL) return false;
                const url = ACTIVE_BACKEND_URL;
                try{
                    const response = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(booking) });
                    if(response.ok){
                        const txt = await response.text();
                        try{ const json = txt ? JSON.parse(txt) : null; if(json && json.error) { console.warn('Backend error on sync:', json); return false; } }catch(e){}
                        return true;
                    }
                }catch(e){
                    console.warn('attemptSyncBooking XHR failed, will try form-post fallback:', e);
                    try{ attemptFormPostBooking(url, booking); return true; }catch(e2){ console.warn('form-post fallback failed:', e2); }
                }
                return false;
            }

            // Handle uploads (temporary)
            if(roomPhotosInput){
                roomPhotosInput.addEventListener('change', function(ev){
                    const files = Array.from(this.files || []).slice(0,3);
                    const room = $('c_room') && $('c_room').value;
                    if(!room){ alert('Please select a room before uploading photos.'); this.value=''; return; }
                    // read files as data URLs
                    const readers = files.map(f=>{
                        return new Promise((res,rej)=>{
                            const r = new FileReader();
                            r.onload = ()=>res(r.result);
                            r.onerror = ()=>res(null);
                            r.readAsDataURL(f);
                        });
                    });
                    Promise.all(readers).then(results=>{
                        const roomKey = normalizeRoomKey(room);
                        uploadedPhotos[roomKey] = results.filter(Boolean).slice(0,3);
                        renderGallery(roomKey);
                        // clear input so same file can be chosen again if needed
                        this.value = '';
                    });
                });
            }

            // placeholder input (persistent)
            if(placeholderFilesInput){
                placeholderFilesInput.addEventListener('change', function(ev){
                    const files = Array.from(this.files || []).slice(0,3);
                    const readers = files.map(f=>{
                        return new Promise((res,rej)=>{
                            const r = new FileReader();
                            r.onload = ()=>res(r.result);
                            r.onerror = ()=>res(null);
                            r.readAsDataURL(f);
                        });
                    });
                    Promise.all(readers).then(results=>{
                        placeholderBuffer = results.filter(Boolean).slice(0,3);
                        // show preview immediately in gallery for current room
                        const room = $('c_room') && $('c_room').value;
                        if(room){
                            const roomKey = normalizeRoomKey(room);
                            uploadedPhotos[roomKey] = placeholderBuffer.slice(0,3);
                            renderGallery(roomKey);
                        }
                        // don't clear the input so user can change mind
                    });
                });
            }

            if(savePlaceholdersBtn){
                savePlaceholdersBtn.addEventListener('click', function(){
                    const room = $('c_room') && $('c_room').value;
                    if(!room) return alert('Select a room first');
                    if(!placeholderBuffer || !placeholderBuffer.length) return alert('Choose up to 3 images first');
                    const roomKey = normalizeRoomKey(room);
                    savedPlaceholders[roomKey] = placeholderBuffer.slice(0,3);
                    try{ localStorage.setItem(PLACEHOLDER_KEY, JSON.stringify(savedPlaceholders)); }catch(e){}
                    // clear temp buffer and re-render using saved placeholders
                    placeholderBuffer = null;
                    delete uploadedPhotos[roomKey];
                    renderGallery(roomKey);
                    if(placeholderFilesInput) placeholderFilesInput.value = '';
                    alert('Placeholders saved for room ' + roomKey);
                });
            }

            if(clearPlaceholdersBtn){
                clearPlaceholdersBtn.addEventListener('click', function(){
                    const room = $('c_room') && $('c_room').value;
                    if(!room) return;
                    const roomKey = normalizeRoomKey(room);
                    delete savedPlaceholders[roomKey];
                    try{ localStorage.setItem(PLACEHOLDER_KEY, JSON.stringify(savedPlaceholders)); }catch(e){}
                    delete uploadedPhotos[roomKey];
                    renderGallery(roomKey);
                    alert('Placeholders cleared for room ' + roomKey);
                });
            }

            // initial render: show default gallery
            renderGallery(null);
            // Ensure availability is rendered for pre-selected room (if any)
            try{ const selRoom = $('c_room') && $('c_room').value; if(selRoom) renderAvailability(selRoom); }catch(e){}

            // Submit -> perform client-side booking (localStorage) and show confirmation
            // Create a single reusable submit handler and attach it to both the form and the submit button
            async function submitBookingHandler(ev){
                try{
                    if(ev && ev.preventDefault) ev.preventDefault();
                    console.log('submitBookingHandler invoked, event type:', ev && ev.type);
                    const statusEl = $('contactStatus');
                    if(statusEl){ statusEl.textContent = 'Processing booking...'; statusEl.style.color = '#666'; }

                    const name = $('c_name') && $('c_name').value.trim();
                    const from = $('c_email') && $('c_email').value.trim();
                    const phone = $('c_phone') && $('c_phone').value.trim();
                    const room = $('c_room') && $('c_room').value.trim();
                    const checkin = $('c_checkin') && $('c_checkin').value;
                    const checkout = $('c_checkout') && $('c_checkout').value;
                    const guests = $('c_guests') && $('c_guests').value;

                    const availEl = $('availabilityStatus');

                    console.log('Form data:', {name, from, phone, room, checkin, checkout, guests});

                    if(!name || !from || !room || !checkin || !checkout || !guests){
                        if(statusEl) { statusEl.textContent = 'Please fill name, email, room, check-in/out and number of guests.'; statusEl.style.color = '#c00'; }
                        console.log('Validation failed: missing required fields');
                        return;
                    }

                    if(new Date(checkin) >= new Date(checkout)){
                        if(statusEl) { statusEl.textContent = 'Check-out must be after check-in.'; statusEl.style.color = '#c00'; }
                        console.log('Validation failed: checkin >= checkout');
                        return;
                    }

                    // Check overlap with existing bookings (public-only data is sufficient)
                    const bookingsToCheck = await loadPublicBookings();
                    const roomBookings = (bookingsToCheck || []).filter(b => String(b.room) === String(room));
                    const conflict = roomBookings.some(b => rangesOverlap(b.checkin, b.checkout, checkin, checkout));
                    if(conflict){
                        if(statusEl) { statusEl.textContent = 'Sorry â€” selected dates conflict with an existing booking. Choose different dates.'; statusEl.style.color = '#c00'; }
                        console.log('Conflict found with existing bookings');
                        return;
                    }

                    if(statusEl) { statusEl.textContent = 'Processing booking...'; statusEl.style.color = '#666'; }
                    if(availEl) { availEl.textContent = ''; }

                    const id = 'BKG-' + Date.now();
                    const booking = { id, room, checkin, checkout, name, email: from, guests, phone, createdAt: new Date().toISOString() };
                    console.log('Created booking object:', booking);

                    const result = await addBooking(booking);
                    console.log('addBooking returned:', result);

                    // Save form copy and show confirmation
                    saveForm();
                    if(statusEl){ statusEl.innerHTML = `âœ“ Booking confirmed â€” reference <strong>${id}</strong>. Thank you, ${name}!`; statusEl.style.color = '#064'; }
                    if(availEl) { availEl.textContent = ''; }
                    if($('c_name')) $('c_name').value = '';
                    if($('c_email')) $('c_email').value = '';
                    if($('c_phone')) $('c_phone').value = '';
                    try{ renderAvailability(room); }catch(e){ console.log('renderAvailability error:', e); }
                    console.log('Booking completed successfully');
                }catch(err){
                    console.error('submitBookingHandler error:', err);
                    const statusEl = $('contactStatus'); if(statusEl) { statusEl.textContent = 'Booking error: ' + (err && err.message ? err.message : String(err)); statusEl.style.color = '#c00'; }
                }
            }

            // Attach handlers
            var contactForm = $('contactForm');
            var submitBtn = document.querySelector('button[type="submit"]');
            console.log('Before attaching handlers - contactForm:', contactForm, 'submitBtn:', submitBtn);
            if(contactForm) contactForm.addEventListener('submit', submitBookingHandler);
            if(submitBtn) submitBtn.addEventListener('click', submitBookingHandler);

            // Refresh availability immediately when bookings change in another tab/window
            window.addEventListener('storage', function(e){
                try{
                    if(!e) return;
                    if(e.key === BOOKINGS_KEY || e.key === 'vb_bookings_updated_at'){
                        const room = $('c_room') && $('c_room').value;
                        if(room){ try{ renderAvailability(room); }catch(err){} }
                    }
                }catch(err){ console.warn('storage event handler error', err); }
            });

    })();
    </script>

    </body>
</html>
